Package minipython;

Helpers
    character = [0..127];

    cr = 13;
	lf = 10;
	space = 32;
	eol = lf | cr | cr lf;

    letter = ['a' .. 'z'] | ['A' .. 'Z'] | '_';
    digit = ['0' .. '9'];
    not_eol = [character - [cr + lf]];
    alphanumerical = letter | digit;


Tokens
    tab = 9;
    number = digit+ | digit+ '.' digit+;
    string = '"' not_eol* '"' | ''' not_eol* ''';
    comment = '#' not_eol* eol;
    blank = space | lf | cr;
    def = 'def';
    plus = '+';
    minus = '-';
    dmult = '**';
    mult = '*';
    div = '/';
    mod = '%';
    logic_plus = '&&';
    l_par = '(';
    r_par = ')';
    l_br = '[';
    r_br = ']';
    comma=',';
    semi = ':';
    equal = '==';
    not_equal = '!=';
    minus_equal = '-=';
    div_equal = '/=';
    less = '<';
    greater = '>';
    less_equal = '<=';
    greater_equal = '>=';
    true = 'true';
    false = 'false';
    not = 'not';
    and = 'and';
    or = 'or';
    assign = '=';
    open = 'open';
    type = 'type';
    max = 'max';
    min = 'min';
    if = 'if';
    while = 'while';
    for = 'for';
    print = 'print';
    return = 'return';
    dot = '.';
    assert = 'assert';
    in = 'in';
    none = 'None';
    id = letter alphanumerical*;

Ignored Tokens
    blank, comment;

Productions

    goal = action*;
    action =  {act1} function | {act2} statement;

    function = def identifier l_par argument? r_par semi statement;

    argument = identifier default_value? multi_argument*;

    default_value = assign value;
    multi_argument = comma identifier default_value?;

    statement = {sta1} tab* if comparison semi statement
              | {sta2} tab* while comparison semi statement
              | {sta3} tab* for [first]:identifier in [second]:identifier semi statement
              | {sta4} tab* return expression
              | {sta5} tab* print expression multi_expression*
              | {sta6} tab* identifier operation_assign expression
              | {sta7} tab* identifier l_br [first]:expression r_br assign [second]:expression
              | {sta8} tab* assert expression multi_expression?
              | {sta9} tab* function_call;

    operation_assign = {op1} assign | {op2} minus_equal | {op3} div_equal;

    expression = plus_minus_expression;

    plus_minus_expression = {exp1} mult_div_expression
                          | {exp2} plus_minus_expression plus mult_div_expression
                          | {exp3} plus_minus_expression minus mult_div_expression;

    mult_div_expression = {exp1} primary_expression
                        | {exp2} mult_div_expression mult primary_expression
                        | {exp3} mult_div_expression dmult primary_expression
                        | {exp4} mult_div_expression div primary_expression
                        | {exp5} mult_div_expression mod primary_expression;

    primary_expression = {exp1} identifier
                       | {exp2} identifier l_br expression r_br
                       | {exp3} value
                       | {exp4} function_call
                       | {exp6} open l_par [first]:expression comma [second]:expression r_par
                       | {exp7} type l_par identifier r_par
                       | {exp8} max l_par value multi_value+ r_par
                       | {exp9} min l_par value multi_value+ r_par
                       | {exp10} l_par expression r_par
                       | {exp11} l_br expression multi_expression* r_br;

    multi_expression = comma expression;

    comparison = {comp1} [first]:comparison operation_logical [second]:logical_expression
               | {comp2} logical_expression;

    logical_expression = {log1} not logical_expression
                       | {log2} [first]:expression comparison_symbol [second]:expression
                       | {log3} true
                       | {log4} false;

    operation_logical = {op1} and | {op2} or;
    comparison_symbol = {op1} greater | {op2} less | {op3} greater_equal | {op4} less_equal | {op5} not_equal | {op6} equal;

    function_call = identifier l_par argument_list? r_par;
    argument_list = expression multi_expression*;

    value = {val1} identifier dot function_call
          | {val2} number
          | {val3} string
          | {val4} none;

    multi_value = comma value;

    identifier = id;